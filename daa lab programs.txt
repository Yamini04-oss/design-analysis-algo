SELECTION SORT:
import java.util.Scanner;

public class SelectionSortCases {
    
    // Selection sort implementation
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            // Swap
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }

    // Method to print array
    public static void printArray(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println();
    }

    // Check if array is sorted in ascending order
    public static boolean isSortedAscending(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i] > arr[i + 1]) {
                return false;
            }
        }
        return true;
    }

    // Check if array is sorted in descending order
    public static boolean isSortedDescending(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i] < arr[i + 1]) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of elements: ");
        int n = sc.nextInt();

        int[] arr = new int[n];
        System.out.println("Enter " + n + " elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        System.out.println("\nOriginal Array:");
        printArray(arr);

        // Analyze case based on input
        if (isSortedAscending(arr)) {
            System.out.println("Input Case: BEST CASE (Array already sorted)");
        } else if (isSortedDescending(arr)) {
            System.out.println("Input Case: WORST CASE (Array sorted in reverse order)");
        } else {
            System.out.println("Input Case: AVERAGE CASE (Random order)");
        }

        // Perform Selection Sort
        selectionSort(arr);

        System.out.println("\nSorted Array:");
        printArray(arr);

        // Complexity explanation
        System.out.println("\nTime Complexity Justification:");
        System.out.println(" - Best Case: O(n^2) (Selection Sort always scans full array even if sorted)");
        System.out.println(" - Worst Case: O(n^2) (Still performs same comparisons, just more swaps)");
        System.out.println(" - Average Case: O(n^2) (Random order still leads to ~n^2/2 comparisons)");
    }
}

BUBBLE SORT
import java.util.*;

public class DetectCaseAndComplexity {

    enum OrderCase { BEST, WORST, AVERAGE }

    // ----- Helpers to detect input order -----
    static boolean isSortedAscending(int[] a) {
        for (int i = 0; i < a.length - 1; i++) if (a[i] > a[i + 1]) return false;
        return true;
    }
    static boolean isSortedDescending(int[] a) {
        for (int i = 0; i < a.length - 1; i++) if (a[i] < a[i + 1]) return false;
        return true;
    }
    static OrderCase detectCase(int[] a) {
        if (isSortedAscending(a)) return OrderCase.BEST;      // for Bubble Sort
        if (isSortedDescending(a)) return OrderCase.WORST;    // for Bubble Sort
        return OrderCase.AVERAGE;
    }

    // ----- Bubble Sort (for sorting output) -----
    static void bubbleSort(int[] arr) {
        int n = arr.length;
        boolean swapped;
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int t = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = t;
                    swapped = true;
                }
            }
            if (!swapped) break;
        }
    }

    static void printArray(int[] a) {
        for (int x : a) System.out.print(x + " ");
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of elements: ");
        int n = sc.nextInt();

        int[] arr = new int[n];
        System.out.println("Enter " + n + " integers:");
        for (int i = 0; i < n; i++) arr[i] = sc.nextInt();

        System.out.println("\nOriginal array:");
        printArray(arr);

        // Detect input pattern once
        OrderCase inputCase = detectCase(arr);

        // ---- Report time complexity for THIS input ----
        // Selection Sort: complexity does NOT change with input order
        System.out.println("\nSelection Sort:");
        System.out.println("Detected input case: " + inputCase);
        System.out.println("Time complexity for this input: O(n^2) (Selection Sort always scans the remaining elements)");

        // Bubble Sort: complexity depends on order
        System.out.println("\nBubble Sort:");
        String bubbleComplexity;
        if (inputCase == OrderCase.BEST) {
            bubbleComplexity = "O(n)  (already sorted ? one pass, no swaps)";
        } else {
            // both reverse-sorted and random behave quadratic
            bubbleComplexity = "O(n^2) (needs multiple passes with swaps/comparisons)";
        }
        System.out.println("Detected input case: " + inputCase);
        System.out.println("Time complexity for this input: " + bubbleComplexity);

        // ---- Show sorted arrays (optional) ----
        int[] a1 = Arrays.copyOf(arr, arr.length);
        int[] a2 = Arrays.copyOf(arr, arr.length);
        selectionSort(a1);
        bubbleSort(a2);

        System.out.println("\nSorted (Selection Sort):");
        printArray(a1);
        System.out.println("Sorted (Bubble Sort):");
        printArray(a2);
    }
}
OUTPUT:
Enter number of elements: 4
Enter 4 integers:
7
2
8
6

Original array:
7 2 8 6 

Bubble Sort:
Detected input case: AVERAGE
Time complexity for this input: O(n^2) (needs multiple passes with swaps/comparisons)

Sorted (Selection Sort):
2 6 7 8 
Sorted (Bubble Sort):
2 6 7 8

INSERTION SORT:
import java.util.*;

public class InsertionSortCases {

    enum OrderCase { BEST, WORST, AVERAGE }

    // ----- Helpers to detect input order -----
    static boolean isSortedAscending(int[] a) {
        for (int i = 0; i < a.length - 1; i++) if (a[i] > a[i + 1]) return false;
        return true;
    }
    static boolean isSortedDescending(int[] a) {
        for (int i = 0; i < a.length - 1; i++) if (a[i] < a[i + 1]) return false;
        return true;
    }
    static OrderCase detectCase(int[] a) {
        if (isSortedAscending(a)) return OrderCase.BEST;
        if (isSortedDescending(a)) return OrderCase.WORST;
        return OrderCase.AVERAGE;
    }

    // ----- Insertion Sort -----
    static void insertionSort(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            // Move elements greater than key one position ahead
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
    }

    static void printArray(int[] a) {
        for (int x : a) System.out.print(x + " ");
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of elements: ");
        int n = sc.nextInt();

        int[] arr = new int[n];
        System.out.println("Enter " + n + " integers:");
        for (int i = 0; i < n; i++) arr[i] = sc.nextInt();

        System.out.println("\nOriginal array:");
        printArray(arr);

        // Detect input pattern
        OrderCase inputCase = detectCase(arr);

        // ---- Report time complexity for THIS input ----
        System.out.println("\nInsertion Sort:");
        String complexity;
        if (inputCase == OrderCase.BEST) {
            complexity = "O(n)   (already sorted ? just one comparison per element)";
        } else if (inputCase == OrderCase.WORST) {
            complexity = "O(n^2) (reverse sorted ? maximum shifts for each element)";
        } else {
            complexity = "O(n^2) (random order ? on average ~n^2/4 shifts)";
        }
        System.out.println("Detected input case: " + inputCase);
        System.out.println("Time complexity for this input: " + complexity);

        // ---- Perform Insertion Sort ----
        insertionSort(arr);

        System.out.println("\nSorted Array:");
        printArray(arr);
    }
}
OUTPUT:
Enter number of elements: 5
Enter 5 integers:
72
5
9
87
65

Original array:
72 5 9 87 65 

Insertion Sort:
Detected input case: AVERAGE
Time complexity for this input: O(n^2) (random order ? on average ~n^2/4 shifts)

Sorted Array: 5 9 65 72 87

MERGE SORT:

import java.util.*;

public class MergeSortProgram {

    enum OrderCase { BEST, WORST, AVERAGE }

    // ----- Helpers to detect input order -----
    static boolean isSortedAscending(int[] a) {
        for (int i = 0; i < a.length - 1; i++) if (a[i] > a[i + 1]) return false;
        return true;
    }
    static boolean isSortedDescending(int[] a) {
        for (int i = 0; i < a.length - 1; i++) if (a[i] < a[i + 1]) return false;
        return true;
    }
    static OrderCase detectCase(int[] a) {
        if (isSortedAscending(a)) return OrderCase.BEST;
        if (isSortedDescending(a)) return OrderCase.WORST;
        return OrderCase.AVERAGE;
    }

    // ----- Merge Sort -----
    static void mergeSort(int[] arr, int l, int r) {
        if (l < r) {
            int m = (l + r) / 2;
            mergeSort(arr, l, m);
            mergeSort(arr, m + 1, r);
            merge(arr, l, m, r);
        }
    }

    static void merge(int[] arr, int l, int m, int r) {
        int n1 = m - l + 1;
        int n2 = r - m;

        int[] L = new int[n1];
        int[] R = new int[n2];

        for (int i = 0; i < n1; i++) L[i] = arr[l + i];
        for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];

        int i = 0, j = 0, k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) arr[k++] = L[i++];
            else arr[k++] = R[j++];
        }

        while (i < n1) arr[k++] = L[i++];
        while (j < n2) arr[k++] = R[j++];
    }

    // ----- Utility -----
    static void printArray(int[] a) {
        for (int x : a) System.out.print(x + " ");
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of elements: ");
        int n = sc.nextInt();

        int[] arr = new int[n];
        System.out.println("Enter " + n + " integers:");
        for (int i = 0; i < n; i++) arr[i] = sc.nextInt();

        System.out.println("\nOriginal Array:");
        printArray(arr);

        // Detect input case
        OrderCase inputCase = detectCase(arr);

        // ---- Complexity report ----
        System.out.println("\nMerge Sort:");
        System.out.println("Detected input case: " + inputCase);
        System.out.println("Time complexity for this input: O(n log n)");
        System.out.println("Reason: Merge Sort always splits and merges recursively,");
        System.out.println("so input order (sorted, reverse, random) does not change its complexity.");

        // ---- Perform Merge Sort ----
        mergeSort(arr, 0, arr.length - 1);

        System.out.println("\nSorted Array:");
        printArray(arr);
    }
}

OUTPUT:

Enter number of elements: 4
Enter 4 integers:
7
5
2
8

Original Array:
7 5 2 8 

Merge Sort:
Detected input case: AVERAGE
Time complexity for this input: O(n log n)
Reason: Merge Sort always splits and merges recursively,
so input order (sorted, reverse, random) does not change its complexity.

Sorted Array:
2 5 7 8
QUICK SORT:

import java.util.*;

public class QuickSortCases {

    enum OrderCase { BEST, WORST, AVERAGE }

    // ----- Helpers to detect input order -----
    static boolean isSortedAscending(int[] a) {
        for (int i = 0; i < a.length - 1; i++) if (a[i] > a[i + 1]) return false;
        return true;
    }
    static boolean isSortedDescending(int[] a) {
        for (int i = 0; i < a.length - 1; i++) if (a[i] < a[i + 1]) return false;
        return true;
    }
    static OrderCase detectCase(int[] a) {
        if (isSortedAscending(a)) return OrderCase.WORST;   // poor pivot leads to worst case
        if (isSortedDescending(a)) return OrderCase.WORST;  // same here
        return OrderCase.AVERAGE;  // assume average for random inputs
    }

    // ----- Quick Sort -----
    static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    static int partition(int[] arr, int low, int high) {
        int pivot = arr[high]; // taking last element as pivot
        int i = (low - 1);
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;
            }
        }
        int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp;
        return i + 1;
    }

    // ----- Utility -----
    static void printArray(int[] a) {
        for (int x : a) System.out.print(x + " ");
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of elements: ");
        int n = sc.nextInt();

        int[] arr = new int[n];
        System.out.println("Enter " + n + " integers:");
        for (int i = 0; i < n; i++) arr[i] = sc.nextInt();

        System.out.println("\nOriginal Array:");
        printArray(arr);

        // Detect input pattern
        OrderCase inputCase = detectCase(arr);

        // ---- Complexity report ----
        System.out.println("\nQuick Sort:");
        System.out.println("Detected input case: " + inputCase);
        if (inputCase == OrderCase.WORST) {
            System.out.println("Time complexity for this input: O(n^2)");
            System.out.println("Reason: Array is sorted (ascending/descending), pivot choice is poor ? unbalanced partitions.");
        } else {
            System.out.println("Time complexity for this input: O(n log n)");
            System.out.println("Reason: Random order ? partitions are roughly balanced on average.");
        }

        // ---- Perform Quick Sort ----
        quickSort(arr, 0, arr.length - 1);

        System.out.println("\nSorted Array:");
        printArray(arr);
    }
}
 OUPPUT:
Enter number of elements: 4
Enter 4 integers:
7
5
4
8

Original Array:
7 5 4 8 

Quick Sort:
Detected input case: AVERAGE
Time complexity for this input: O(n log n)
Reason: Random order ? partitions are roughly balanced on average.

Sorted Array:
4 5 7 8


Implement Knapsack problem using Greedy Method
import java.util.*;

class Item {
    int weight, value;
    double ratio; // value/weight

    Item(int weight, int value) {
        this.weight = weight;
        this.value = value;
        this.ratio = (double) value / weight;
    }
}

public class FractionalKnapsackGreedy {

    // Greedy method
    static double knapsack(int W, Item[] items) {
        // Sort items by value-to-weight ratio (descending order)
        Arrays.sort(items, (a, b) -> Double.compare(b.ratio, a.ratio));

        double totalValue = 0.0;
        int currentWeight = 0;

        for (Item item : items) {
            if (currentWeight + item.weight <= W) {
                // Take full item
                currentWeight += item.weight;
                totalValue += item.value;
            } else {
                // Take fraction of item
                int remaining = W - currentWeight;
                totalValue += item.value * ((double) remaining / item.weight);
                break; // knapsack is full
            }
        }
        return totalValue;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Input
        System.out.print("Enter number of items: ");
        int n = sc.nextInt();

        Item[] items = new Item[n];
        System.out.println("Enter weight and value of each item:");
        for (int i = 0; i < n; i++) {
            int w = sc.nextInt();
            int v = sc.nextInt();
            items[i] = new Item(w, v);
        }

        System.out.print("Enter Knapsack capacity: ");
        int W = sc.nextInt();

        // Solve
        double maxValue = knapsack(W, items);

        System.out.println("\nMaximum value obtained = " + maxValue);
    }
}
OUTPUT:
Enter number of items: 3
Enter weight and value of each item:
8
5
7
6
8
3
Enter Knapsack capacity: 10

Maximum value obtained = 7.875

Implement Knapsack problem using Dynamic Programming
import java.util.*;

public class KnapsackDP {

    static class Item {
        int weight, value;
        Item(int w, int v) { weight = w; value = v; }
    }

    // 0/1 Knapsack DP with reconstruction of chosen items
    static int knapsack(Item[] items, int W, List<Integer> chosenIndices) {
        int n = items.length;
        int[][] dp = new int[n + 1][W + 1];

        // Build table dp[i][w] = best value using first i items and capacity w
        for (int i = 1; i <= n; i++) {
            int wt = items[i - 1].weight;
            int val = items[i - 1].value;
            for (int w = 0; w <= W; w++) {
                dp[i][w] = dp[i - 1][w]; // not taking item i-1
                if (wt <= w) {
                    dp[i][w] = Math.max(dp[i][w], dp[i - 1][w - wt] + val);
                }
            }
        }

        // Reconstruct chosen items (indices in original 0-based order)
        int w = W;
        for (int i = n; i >= 1; i--) {
            if (dp[i][w] != dp[i - 1][w]) {
                // item i-1 was taken
                chosenIndices.add(i - 1);
                w -= items[i - 1].weight;
            }
            if (w == 0) break;
        }
        Collections.reverse(chosenIndices);

        return dp[n][W];
    }

    // Optional: space-optimized DP for large n with no reconstruction
    static int knapsack1D(Item[] items, int W) {
        int[] dp = new int[W + 1];
        for (Item it : items) {
            for (int w = W; w >= it.weight; w--) {
                dp[w] = Math.max(dp[w], dp[w - it.weight] + it.value);
            }
        }
        return dp[W];
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of items: ");
        int n = sc.nextInt();

        Item[] items = new Item[n];
        System.out.println("Enter weight and value for each item (weight value):");
        for (int i = 0; i < n; i++) {
            int w = sc.nextInt();
            int v = sc.nextInt();
            items[i] = new Item(w, v);
        }

        System.out.print("Enter knapsack capacity: ");
        int W = sc.nextInt();

        List<Integer> chosen = new ArrayList<>();
        int maxVal = knapsack(items, W, chosen);

        System.out.println("\nMaximum value = " + maxVal);
        System.out.println("Chosen items (0-based index: weight, value):");
        int totalWeight = 0;
        for (int idx : chosen) {
            System.out.println("  Item " + idx + ": (" + items[idx].weight + ", " + items[idx].value + ")");
            totalWeight += items[idx].weight;
        }
        System.out.println("Total chosen weight = " + totalWeight + " / capacity " + W);

        // If you just need the value and have large W, consider the 1D version:
        // System.out.println("Max value (1D DP, no reconstruction) = " + knapsack1D(items, W));
    }
}
OUTPUT:
Enter number of items: 3
Enter weight and value for each item (weight value):
7
8
9
5
6
4
Enter knapsack capacity: 20

Maximum value = 13
Chosen items (0-based index: weight, value):
  Item 0: (7, 8)
  Item 1: (9, 5)
Total chosen weight = 16 / capacity 20


Implement Job Sequencing using deadlines using Greedy method
import java.util.*;

public class JobSequencingGreedy {

    static class Job {
        String id;     // job identifier
        int deadline;  // deadline (time slot, 1..D)
        int profit;    // profit if done before/at deadline
        Job(String id, int deadline, int profit) {
            this.id = id; this.deadline = deadline; this.profit = profit;
        }
    }

    // Greedy: sort by profit desc, place each job in the latest free slot ? deadline
    static List<Job> scheduleJobs(Job[] jobs) {
        // sort by profit descending
        Arrays.sort(jobs, (a, b) -> Integer.compare(b.profit, a.profit));

        // find max deadline to size slots
        int maxD = 0;
        for (Job j : jobs) maxD = Math.max(maxD, j.deadline);

        // slots[t] = job index scheduled at time t (1..maxD), -1 if free
        int[] slots = new int[maxD + 1];
        Arrays.fill(slots, -1);

        // keep selected jobs in their scheduled order (by time slot)
        Job[] placedAt = new Job[maxD + 1];

        for (int i = 0; i < jobs.length; i++) {
            Job j = jobs[i];
            // try to schedule at the latest available slot ? deadline
            for (int t = Math.min(j.deadline, maxD); t >= 1; t--) {
                if (slots[t] == -1) {
                    slots[t] = i;
                    placedAt[t] = j;
                    break;
                }
            }
        }

        // build result in chronological order of execution
        List<Job> result = new ArrayList<>();
        for (int t = 1; t <= maxD; t++) if (placedAt[t] != null) result.add(placedAt[t]);
        return result;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of jobs: ");
        int n = sc.nextInt();

        Job[] jobs = new Job[n];
        System.out.println("Enter each job as: <id> <deadline> <profit>");
        System.out.println("(Example: J1 2 100)");
        for (int i = 0; i < n; i++) {
            String id = sc.next();
            int d = sc.nextInt();
            int p = sc.nextInt();
            jobs[i] = new Job(id, d, p);
        }

        List<Job> schedule = scheduleJobs(jobs);

        int totalProfit = 0;
        StringBuilder order = new StringBuilder();
        for (int i = 0; i < schedule.size(); i++) {
            Job j = schedule.get(i);
            totalProfit += j.profit;
            if (i > 0) order.append(" -> ");
            order.append(j.id);
        }

        System.out.println("\nSelected job order: " + (schedule.isEmpty() ? "(none)" : order));
        System.out.println("Number of jobs done: " + schedule.size());
        System.out.println("Total profit: " + totalProfit);
    }
}
OUTPUT:
Enter number of jobs: 4
Enter each job as: <id> <deadline> <profit>
(Example: J1 2 100)
J1 1 100
J2 2 200
J3 1 150
J4 2 250

Selected job order: J2 -> J4
Number of jobs done: 2
Total profit: 450

Find Minimum Cost Spanning Tree of a given undirected graph using Kruskal’s algorithm
import java.util.*;

/**
 * Kruskal's Algorithm for Minimum Spanning Tree (Undirected Graph)
 * Input format (1-based vertices):
 *   n m
 *   u1 v1 w1
 *   u2 v2 w2
 *   ...
 * Example:
 *   4 5
 *   1 2 10
 *   1 3 6
 *   1 4 5
 *   2 4 15
 *   3 4 4
 */
public class KruskalMST {

    static class Edge {
        int u, v, w;
        Edge(int u, int v, int w) { this.u = u; this.v = v; this.w = w; }
    }

    // Disjoint Set Union (Union-Find)
    static class DSU {
        int[] parent, rank;
        DSU(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) parent[i] = i;
        }
        int find(int x) {
            if (parent[x] != x) parent[x] = find(parent[x]); // path compression
            return parent[x];
        }
        boolean union(int a, int b) {
            int ra = find(a), rb = find(b);
            if (ra == rb) return false;
            if (rank[ra] < rank[rb]) parent[ra] = rb;
            else if (rank[ra] > rank[rb]) parent[rb] = ra;
            else { parent[rb] = ra; rank[ra]++; }
            return true;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of vertices and edges (n m): ");
        int n = sc.nextInt();
        int m = sc.nextInt();

        List<Edge> edges = new ArrayList<>();
        System.out.println("Enter edges as: u v w  (1-based vertices)");
        for (int i = 0; i < m; i++) {
            int u = sc.nextInt() - 1; // convert to 0-based
            int v = sc.nextInt() - 1;
            int w = sc.nextInt();
            edges.add(new Edge(u, v, w));
        }

        // Kruskal: sort edges by weight
        edges.sort(Comparator.comparingInt(e -> e.w));

        DSU dsu = new DSU(n);
        List<Edge> mst = new ArrayList<>();
        long totalCost = 0;

        for (Edge e : edges) {
            if (dsu.union(e.u, e.v)) {
                mst.add(e);
                totalCost += e.w;
                if (mst.size() == n - 1) break; // MST complete
            }
        }

        if (mst.size() != n - 1) {
            System.out.println("\nGraph is disconnected — MST does not exist.");
            System.out.println("A maximum spanning forest for connected components is shown below:");
        } else {
            System.out.println("\nMinimum Spanning Tree (Kruskal):");
        }

        System.out.println("Edges in the MST/forest (u - v : w):");
        for (Edge e : mst) {
            System.out.println((e.u + 1) + " - " + (e.v + 1) + " : " + e.w);
        }
        System.out.println("Total cost = " + totalCost);
    }
}
OUTPUT
Enter number of vertices and edges (n m): 4
5
Enter edges as: u v w  (1-based vertices)
1 2 10
1 3 6
1 4 5
2 4 15
3 4 4

Minimum Spanning Tree (Kruskal):
Edges in the MST/forest (u - v : w):
3 - 4 : 4
1 - 4 : 5
1 - 2 : 10
Total cost = 19
Find Minimum Cost Spanning Tree of a given undirected graph using Prim’s algorithm
import java.util.*;

/**
 * Prim's Algorithm for Minimum Spanning Tree (Undirected Graph)
 * Input (1-based vertices):
 *   n m
 *   u1 v1 w1
 *   u2 v2 w2
 *   ...
 * Example:
 *   4 5
 *   1 2 10
 *   1 3 6
 *   1 4 5
 *   2 4 15
 *   3 4 4
 */
public class PrimMST {

    // adjacency edge
    static class Edge {
        int to, w;
        Edge(int to, int w) { this.to = to; this.w = w; }
    }

    // picked edge in MST/forest (parent -> u with weight w)
    static class Pick implements Comparable<Pick> {
        int w, u, parent; // parent = -1 for starting vertex
        Pick(int w, int u, int parent) { this.w = w; this.u = u; this.parent = parent; }
        public int compareTo(Pick other) { return Integer.compare(this.w, other.w); }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of vertices and edges (n m): ");
        int n = sc.nextInt();
        int m = sc.nextInt();

        List<List<Edge>> g = new ArrayList<>();
        for (int i = 0; i < n; i++) g.add(new ArrayList<>());

        System.out.println("Enter edges as: u v w  (1-based vertices)");
        for (int i = 0; i < m; i++) {
            int u = sc.nextInt() - 1; // to 0-based
            int v = sc.nextInt() - 1;
            int w = sc.nextInt();
            g.get(u).add(new Edge(v, w));
            g.get(v).add(new Edge(u, w));
        }

        // Prim across components (minimum spanning forest if disconnected)
        boolean[] vis = new boolean[n];
        List<int[]> chosenEdges = new ArrayList<>(); // store as {u, v, w} in 0-based
        long totalCost = 0;
        int components = 0;

        PriorityQueue<Pick> pq = new PriorityQueue<>();

        for (int s = 0; s < n; s++) {
            if (vis[s]) continue;
            components++;
            pq.add(new Pick(0, s, -1)); // start a new component
            while (!pq.isEmpty()) {
                Pick cur = pq.poll();
                if (vis[cur.u]) continue;
                vis[cur.u] = true;

                if (cur.parent != -1) {
                    chosenEdges.add(new int[]{cur.parent, cur.u, cur.w});
                    totalCost += cur.w;
                }

                for (Edge e : g.get(cur.u)) {
                    if (!vis[e.to]) pq.add(new Pick(e.w, e.to, cur.u));
                }
            }
        }

        if (components > 1) {
            System.out.println("\nGraph is disconnected — showing Minimum Spanning Forest (Prim per component):");
        } else {
            System.out.println("\nMinimum Spanning Tree (Prim):");
        }

        System.out.println("Edges (u - v : w):");
        for (int[] e : chosenEdges) {
            System.out.println((e[0] + 1) + " - " + (e[1] + 1) + " : " + e[2]); // back to 1-based
        }
        System.out.println("Total cost = " + totalCost);
    }
}

OUTPUT:
Enter number of vertices and edges (n m): 4 5
Enter edges as: u v w  (1-based vertices)
1 2 10 
1 3 6
1 4 5
2 4 15
3 4 4

Minimum Spanning Tree (Prim):
Edges (u - v : w):
1 - 4 : 5
4 - 3 : 4
1 - 2 : 10
Total cost = 19
From a given vertex in a weighted connected graph, find shortest paths to other vertices       using Dijkstra’s algorithm

import java.util.*;

/**
 * Dijkstra's Algorithm for Single-Source Shortest Paths
 * Input format (1-based vertices):
 *   n m
 *   u1 v1 w1
 *   u2 v2 w2
 *   ...
 *   source
 * Example:
 *   5 6
 *   1 2 10
 *   1 3 3
 *   2 3 1
 *   2 4 2
 *   3 2 4
 *   3 4 8
 *   1
 */
public class DijkstraShortestPath {

    static class Edge {
        int to, weight;
        Edge(int to, int w) { this.to = to; this.weight = w; }
    }

    static class Node implements Comparable<Node> {
        int vertex, dist;
        Node(int v, int d) { vertex = v; dist = d; }
        public int compareTo(Node o) { return Integer.compare(this.dist, o.dist); }
    }

    static void dijkstra(List<List<Edge>> graph, int src) {
        int n = graph.size();
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[src] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.add(new Node(src, 0));

        while (!pq.isEmpty()) {
            Node cur = pq.poll();
            int u = cur.vertex;
            int d = cur.dist;

            if (d > dist[u]) continue; // stale entry

            for (Edge e : graph.get(u)) {
                if (dist[u] + e.weight < dist[e.to]) {
                    dist[e.to] = dist[u] + e.weight;
                    pq.add(new Node(e.to, dist[e.to]));
                }
            }
        }

        // Print shortest paths
        System.out.println("\nShortest distances from source " + (src + 1) + ":");
        for (int i = 0; i < n; i++) {
            System.out.println("Vertex " + (i + 1) + " : " + dist[i]);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of vertices and edges (n m): ");
        int n = sc.nextInt();
        int m = sc.nextInt();

        List<List<Edge>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());

        System.out.println("Enter edges as: u v w (1-based vertices, weight w):");
        for (int i = 0; i < m; i++) {
            int u = sc.nextInt() - 1; 
            int v = sc.nextInt() - 1;
            int w = sc.nextInt();
            graph.get(u).add(new Edge(v, w));
            graph.get(v).add(new Edge(u, w)); // undirected graph
        }

        System.out.print("Enter source vertex (1-based): ");
        int src = sc.nextInt() - 1;

        dijkstra(graph, src);
    }
}

OUTPUT:

Enter number of vertices and edges (n m): 5 6
Enter edges as: u v w (1-based vertices, weight w):
1 2 10
1 3 3
2 3 1
2 4 2
3 2 4
3 4 8
Enter source vertex (1-based): 1

Shortest distances from source 1:
Vertex 1 : 0
Vertex 2 : 4
Vertex 3 : 3
Vertex 4 : 6
Vertex 5 : 2147483647
Implement All-Pairs Shortest Paths Problem using Floyd’s algorithm:
import java.util.*;

public class FloydWarshall {

    static final long INF = (long)1e15; // a big "infinity" that won't overflow when adding

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // ---- Input ----
        System.out.print("Enter number of vertices and edges (n m): ");
        int n = sc.nextInt();
        int m = sc.nextInt();

        System.out.print("Is the graph Undirected (U) or Directed (D)? Enter U/D: ");
        char type = sc.next().trim().toUpperCase().charAt(0);
        boolean undirected = (type == 'U');

        // dist[i][j] = shortest distance from i to j
        long[][] dist = new long[n][n];
        int[][] next = new int[n][n]; // for path reconstruction

        // Initialize
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], INF);
            Arrays.fill(next[i], -1);
            dist[i][i] = 0;
            next[i][i] = i;
        }

        System.out.println("Enter edges as: u v w (1-based vertices, weight w; negative edges allowed, no negative cycles):");
        for (int i = 0; i < m; i++) {
            int u = sc.nextInt() - 1;
            int v = sc.nextInt() - 1;
            long w = sc.nextLong();

            // Keep the minimum weight if multiple edges exist
            if (w < dist[u][v]) {
                dist[u][v] = w;
                next[u][v] = v;
            }
            if (undirected) {
                if (w < dist[v][u]) {
                    dist[v][u] = w;
                    next[v][u] = u;
                }
            }
        }

        // ---- Floyd–Warshall ----
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                if (dist[i][k] == INF) continue; // small speed-ups
                for (int j = 0; j < n; j++) {
                    if (dist[k][j] == INF) continue;
                    long cand = dist[i][k] + dist[k][j];
                    if (cand < dist[i][j]) {
                        dist[i][j] = cand;
                        next[i][j] = next[i][k]; // first hop from i toward j
                    }
                }
            }
        }

        // ---- Detect negative cycles ----
        boolean hasNegCycle = false;
        for (int v = 0; v < n; v++) {
            if (dist[v][v] < 0) { hasNegCycle = true; break; }
        }

        // If negative cycle affects a pair (i,j), mark distance as -INF-ish and path undefined
        if (hasNegCycle) {
            // Standard propagation: if k is on a negative cycle and is reachable i->k->j, then i->j is -inf
            for (int k = 0; k < n; k++) {
                if (dist[k][k] < 0) {
                    for (int i = 0; i < n; i++) if (dist[i][k] != INF)
                        for (int j = 0; j < n; j++) if (dist[k][j] != INF) {
                            dist[i][j] = -INF; // signal
                            next[i][j] = -1;
                        }
                }
            }
        }

        // ---- Print distance matrix ----
        System.out.println("\nAll-Pairs Shortest Distances:");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][j] == INF) System.out.print("INF ");
                else if (dist[i][j] == -INF) System.out.print("-INF ");
                else System.out.print(dist[i][j] + " ");
            }
            System.out.println();
        }

        if (hasNegCycle) {
            System.out.println("\nWarning: Graph contains a negative cycle that affects some shortest paths.");
            System.out.println("Pairs marked as -INF are reachable through paths of arbitrarily low total cost.");
        }

        // ---- Optional: query paths ----
        System.out.print("\nDo you want to query a path (Y/N)? ");
        char q = sc.next().trim().toUpperCase().charAt(0);
        while (q == 'Y') {
            System.out.print("Enter source and target (1-based): ");
            int s = sc.nextInt() - 1, t = sc.nextInt() - 1;

            List<Integer> path = reconstructPath(s, t, next);
            if (path == null) {
                System.out.println("No path exists from " + (s + 1) + " to " + (t + 1) + ".");
            } else if (dist[s][t] == -INF) {
                System.out.println("Path cost is -INF (affected by a negative cycle).");
            } else {
                System.out.print("Path: ");
                for (int i = 0; i < path.size(); i++) {
                    if (i > 0) System.out.print(" -> ");
                    System.out.print(path.get(i) + 1); // back to 1-based
                }
                System.out.println("\nTotal distance: " + dist[s][t]);
            }

            System.out.print("\nQuery another path (Y/N)? ");
            q = sc.next().trim().toUpperCase().charAt(0);
        }
    }

    // Reconstructs path s -> t using the "next" matrix
    static List<Integer> reconstructPath(int s, int t, int[][] next) {
        if (s < 0 || s >= next.length || t < 0 || t >= next.length) return null;
        if (next[s][t] == -1) return null; // no path
        List<Integer> path = new ArrayList<>();
        int at = s;
        while (at != t) {
            path.add(at);
            at = next[at][t];
            if (at == -1) return null; // safety
        }
        path.add(t);
        return path;
    }
}
OUTPUT:
Enter number of vertices and edges (n m): 4 4
Is the graph Undirected (U) or Directed (D)? Enter U/D: D
Enter edges as: u v w (1-based vertices, weight w; negative edges allowed, no negative cycles):
1 2 10
1 2 20
2 4 5
3 4 4

All-Pairs Shortest Distances:
0 10 INF 15 
INF 0 INF 5 
INF INF 0 4 
INF INF INF 0 

Do you want to query a path (Y/N)? Y
Enter source and target (1-based): 1 4
Path: 1 -> 2 -> 4
Total distance: 15

Query another path (Y/N)?
Implement Travelling Salesperson Problem using Dynamic Programming:
import java.util.*;

public class TSPHeldKarp {

    static final long INF = (long) 1e15;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // ---- Input ----
        System.out.print("Enter number of cities n: ");
        int n = sc.nextInt();

        long[][] cost = new long[n][n];
        System.out.println("Enter the " + n + "x" + n + " cost matrix (use -1 for no edge):");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                long w = sc.nextLong();
                if (i == j) {
                    cost[i][j] = 0;  // ignore self-loop weight
                } else {
                    cost[i][j] = (w == -1 ? INF : w);
                }
            }
        }

        System.out.print("Enter start city (1-based): ");
        int start1 = sc.nextInt();
        int start = start1 - 1;

        // ---- DP arrays ----
        int FULL = 1 << n;
        long[][] dp = new long[FULL][n];
        int[][] parent = new int[FULL][n]; // to reconstruct path

        for (int m = 0; m < FULL; m++) Arrays.fill(dp[m], INF);
        for (int m = 0; m < FULL; m++) Arrays.fill(parent[m], -1);

        int startMask = 1 << start;
        dp[startMask][start] = 0;

        // ---- DP transitions ----
        for (int mask = 0; mask < FULL; mask++) {
            if ((mask & startMask) == 0) continue; // must include start
            for (int u = 0; u < n; u++) {
                if ((mask & (1 << u)) == 0) continue; // u not in mask
                long cur = dp[mask][u];
                if (cur >= INF) continue;
                for (int v = 0; v < n; v++) {
                    if ((mask & (1 << v)) != 0) continue; // already visited v
                    if (cost[u][v] >= INF) continue;      // no edge
                    int nextMask = mask | (1 << v);
                    long cand = cur + cost[u][v];
                    if (cand < dp[nextMask][v]) {
                        dp[nextMask][v] = cand;
                        parent[nextMask][v] = u;
                    }
                }
            }
        }

        // ---- Close the tour (return to start) ----
        int fullMask = FULL - 1;
        long bestCost = INF;
        int last = -1;
        for (int u = 0; u < n; u++) {
            if (u == start) continue;
            if (dp[fullMask][u] >= INF || cost[u][start] >= INF) continue;
            long cand = dp[fullMask][u] + cost[u][start];
            if (cand < bestCost) {
                bestCost = cand;
                last = u;
            }
        }

        if (bestCost >= INF) {
            System.out.println("\nNo Hamiltonian tour exists (graph too sparse/disconnected).");
            return;
        }

        // ---- Reconstruct optimal tour ----
        List<Integer> tour = new ArrayList<>();
        int mask = fullMask, cur = last;
        while (cur != -1) {
            tour.add(cur);
            int p = parent[mask][cur];
            mask ^= (1 << cur);
            cur = p;
        }
        tour.add(start);           // add the start (we ended when parent = -1 at start)
        Collections.reverse(tour); // now from start ... last

        // Close the cycle by returning to start (for printing)
        tour.add(start);

        // ---- Output ----
        System.out.println("\nMinimum tour cost = " + bestCost);
        System.out.print("Optimal tour (1-based): ");
        for (int i = 0; i < tour.size(); i++) {
            if (i > 0) System.out.print(" -> ");
            System.out.print(tour.get(i) + 1);
        }
        System.out.println();
    }
}
OUTPUT:
Enter number of cities n: 4
Enter the 4x4 cost matrix (use -1 for no edge):
0 10 15 20
5 0 9 10
6 13 0 12
8 8 9 0
Enter start city (1-based): 1

Minimum tour cost = 35
Optimal tour (1-based): 1 -> 1 -> 2 -> 4 -> 3 -> 1
Implement the following using Back Tracking N Queen’s problem
import java.util.*;

public class NQueensBacktracking {

    static List<List<String>> solutions = new ArrayList<>();

    // Backtracking: try to place a queen row by row
    static void solveNQueens(int n) {
        char[][] board = new char[n][n];
        for (char[] row : board) Arrays.fill(row, '.');

        boolean[] col = new boolean[n];          // columns under attack
        boolean[] d1  = new boolean[2*n - 1];    // main diagonals (r - c + n - 1)
        boolean[] d2  = new boolean[2*n - 1];    // anti diagonals (r + c)

        backtrack(0, n, board, col, d1, d2);
    }

    static void backtrack(int r, int n, char[][] board,
                          boolean[] col, boolean[] d1, boolean[] d2) {
        if (r == n) {
            // collect a solution
            List<String> sol = new ArrayList<>(n);
            for (int i = 0; i < n; i++) sol.add(new String(board[i]));
            solutions.add(sol);
            return;
        }

        for (int c = 0; c < n; c++) {
            int id1 = r - c + n - 1;
            int id2 = r + c;
            if (col[c] || d1[id1] || d2[id2]) continue;

            // place queen
            board[r][c] = 'Q';
            col[c] = d1[id1] = d2[id2] = true;

            backtrack(r + 1, n, board, col, d1, d2);

            // remove queen
            board[r][c] = '.';
            col[c] = d1[id1] = d2[id2] = false;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter N (size of the board): ");
        int n = sc.nextInt();

        solutions.clear();
        solveNQueens(n);

        if (solutions.isEmpty()) {
            System.out.println("\nNo solutions exist for N = " + n + ".");
            return;
        }

        System.out.println("\nTotal solutions for N = " + n + " : " + solutions.size());
        for (int k = 0; k < solutions.size(); k++) {
            System.out.println("\nSolution " + (k + 1) + ":");
            for (String row : solutions.get(k)) {
                System.out.println(row);
            }
        }
    }
}

OUTPUT:
Enter N (size of the board): 4

Total solutions for N = 4 : 2

Solution 1:
.Q..
...Q
Q...
..Q.

Solution 2:
..Q.
Q...
...Q
.Q..

Implement the following using Back Tracking Hamiltonian Cycle
import java.util.*;

public class HamiltonianCycleBacktracking {

    // --- Backtracking core (using adjacency matrix) ---
    static boolean hamCycle(int[][] g, int n, List<Integer> cycle) {
        // cycle[0] is fixed to 0 (vertex 1 in 1-based)
        cycle.add(0);
        boolean[] used = new boolean[n];
        used[0] = true;
        return backtrack(1, g, n, cycle, used);
    }

    static boolean backtrack(int pos, int[][] g, int n, List<Integer> cycle, boolean[] used) {
        // If we placed n vertices, check if there is an edge back to start to form a cycle
        if (pos == n) {
            int last = cycle.get(n - 1);
            int first = cycle.get(0);
            return g[last][first] == 1;
        }

        // Try all vertices as next candidate
        for (int v = 1; v < n; v++) { // start from 1; 0 is fixed at start
            if (!used[v] && g[cycle.get(pos - 1)][v] == 1) {
                used[v] = true;
                cycle.add(v);

                if (backtrack(pos + 1, g, n, cycle, used)) return true;

                // backtrack
                used[v] = false;
                cycle.remove(cycle.size() - 1);
            }
        }
        return false;
    }

    // --- Driver / I/O ---
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of vertices and edges (n m): ");
        int n = sc.nextInt();
        int m = sc.nextInt();

        int[][] g = new int[n][n];
        System.out.println("Enter edges (undirected) as: u v   (1-based)");
        for (int i = 0; i < m; i++) {
            int u = sc.nextInt() - 1;
            int v = sc.nextInt() - 1;
            g[u][v] = g[v][u] = 1;
        }

        List<Integer> cycle = new ArrayList<>();
        boolean ok = hamCycle(g, n, cycle);

        if (!ok) {
            System.out.println("\nNo Hamiltonian cycle exists.");
        } else {
            // close the cycle visually by appending the start again
            System.out.println("\nHamiltonian cycle (1-based):");
            for (int i = 0; i < cycle.size(); i++) {
                if (i > 0) System.out.print(" -> ");
                System.out.print(cycle.get(i) + 1);
            }
            System.out.println(" -> " + (cycle.get(0) + 1));
        }
    }
}

OUTPUT:

Enter number of vertices and edges (n m): 4
6
Enter edges (undirected) as: u v   (1-based)
1 2
1 3
1 4
2 3
2 4
3 4

Hamiltonian cycle (1-based):
1 -> 2 -> 3 -> 4 -> 1
Implement the following using Back Tracking Graph Coloring
import java.util.*;

public class GraphColoringBacktracking {

    // Adjacency matrix for simplicity
    static boolean[][] adj;
    static int n, m, k;
    static int[] color; // color[v] in 1..k, 0 = uncolored

    static boolean isSafe(int v, int c) {
        for (int u = 0; u < n; u++) {
            if (adj[v][u] && color[u] == c) return false;
        }
        return true;
    }

    // Find ONE coloring
    static boolean colorGraph(int v) {
        if (v == n) return true; // all vertices colored

        for (int c = 1; c <= k; c++) {
            if (isSafe(v, c)) {
                color[v] = c;
                if (colorGraph(v + 1)) return true;
                color[v] = 0; // backtrack
            }
        }
        return false;
    }

    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of vertices, edges, and colors (n m k): ");
        n = sc.nextInt();
        m = sc.nextInt();
        k = sc.nextInt();

        adj = new boolean[n][n];
        System.out.println("Enter " + m + " edges as: u v  (1-based, undirected)");
        for (int i = 0; i < m; i++) {
            int u = sc.nextInt() - 1;
            int v = sc.nextInt() - 1;
            if (u >= 0 && v >= 0 && u < n && v < n && u != v) {
                adj[u][v] = adj[v][u] = true;
            }
        }

        color = new int[n];

        // Find one solution
        boolean ok = colorGraph(0);

        if (!ok) {
            System.out.println("\nNo valid " + k + "-coloring exists for this graph.");
        } else {
            System.out.println("\nA valid " + k + "-coloring (vertex : color):");
            for (int v = 0; v < n; v++) {
                System.out.println("Vertex " + (v + 1) + " : " + color[v]);
            }
        }

            }
}

OUTPUT:
Enter number of vertices, edges, and colors (n m k): 4 4 2
Enter 4 edges as: u v  (1-based, undirected)
1 2
1 3
2 4
3 4

A valid 2-coloring (vertex : color):
Vertex 1 : 1
Vertex 2 : 2
Vertex 3 : 2
Vertex 4 : 1
Implement pattern matching using knuth morrispratt algorithm
import java.io.*;
import java.util.*;

public class KMPPatternMatching {

    // Build LPS (Longest Proper Prefix which is also Suffix) array for pattern
    static int[] buildLPS(String pat) {
        int m = pat.length();
        int[] lps = new int[m];
        int len = 0; // length of the previous longest prefix suffix
        int i = 1;
        while (i < m) {
            if (pat.charAt(i) == pat.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1]; // fall back
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }

    // KMP search: return all start indices (0-based) where pat occurs in text
    static List<Integer> kmpSearch(String text, String pat) {
        List<Integer> hits = new ArrayList<>();
        int n = text.length(), m = pat.length();
        if (m == 0) return hits; // define empty pattern: no matches printed

        int[] lps = buildLPS(pat);
        int i = 0, j = 0; // i -> text, j -> pattern

        while (i < n) {
            if (text.charAt(i) == pat.charAt(j)) {
                i++; j++;
                if (j == m) {
                    hits.add(i - j);     // match found at i - j
                    j = lps[j - 1];      // continue searching for next match
                }
            } else {
                if (j != 0) j = lps[j - 1];
                else i++;
            }
        }
        return hits;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        System.out.print("Enter text: ");
        String text = br.readLine();

        System.out.print("Enter pattern: ");
        String pat = br.readLine();

        if (pat == null || pat.length() == 0) {
            System.out.println("\nPattern is empty. Nothing to search.");
            return;
        }

        List<Integer> matches = kmpSearch(text, pat);

        System.out.println("\nTotal matches: " + matches.size());
        if (matches.isEmpty()) {
            System.out.println("No occurrences found.");
        } else {
            System.out.println("Start indices (0-based): " + matches);
            // Also print 1-based positions
            List<Integer> oneBased = new ArrayList<>();
            for (int idx : matches) oneBased.add(idx + 1);
            System.out.println("Start indices (1-based): " + oneBased);
        }
    }
}
OUTPUT:

Enter text: Stanley College of Engineering and technology for Women
Enter pattern: neering

Total matches: 1
Start indices (0-based): [23]
Start indices (1-based): [24]
